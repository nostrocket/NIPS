# NIP 31108 - Sovereign Economic Communities (SEC)
##### NIP1962 STATUS: RAW
A Sovereign Economic Community (aka a *Rocket*) is a coordination layer that harmonises Sovereign Human Action for fun and profit.

## Protocol Flow
The history of an SEC is stored using a Microsubjective Blockchain (MSB): a linked list of nostr events that anyone can fork and/or append to. Client implementations use Web of Trust combined with proof verification to determine which fork to follow. 

The tip of the MSB is a replaceable event (kind `31108`) that contains the current state of the SEC and the event ID of the previous state (most relay implementations provide the previous versions of replaced events if requested by ID). 

Instead of verifying the entire history of the linked list, one MAY consume the current state from pubkeys they trust. 

1. The project creator publishes a `kind 31108` event to create a new SEC. This is called the `ignition` event.
2. Anyone can fork and modify the state of the SEC by publishing a replacement `31108` event with the new state and proof(s) that the modification follows the protocol ruleset indicated by the `ignition` event.
3. A replacement `31108` event (i.e. all except the `ignition` event) MUST provide the ID of the `ignition` event at the root of this MSB, AND the ID of the most recent `31108` event that this builds upon.
4. To find the current state of the SEC, we request the latest `31108` events that have tagged the `ignition` event (from pubkeys we trust), and OPTIONALLY perform validation on the entire MSB back to the `ignition` event.
5. To signal that we are following a particular MSB tip, we publish a `31108` event to `shadow` it.

## SEC State Event (kind: 31108)
The following tags are indicated for use in kind 31108 events.

### Metadata
| RFC 2119 | Description | Spec or Example |
|---|---|---|
|MUST|Ruleset identifier - the ruleset(s) that this MSB validates against.|`["ruleset", <hex>]`|
|SHOULD| Pointer to the `kind 31108` ignition event for this SEC. | `[ "ignition", <event ID> ]` |
|SHOULD| Pointer to the ID of the last `kind 31108` that this replacement is updating (MUST be the same pubkey). | `[ "parent", <event ID> ]` |
| MUST | The name of this SEC. | `[ "d", <name of this SEC> ]` |
| OPTIONAL | This is to signal that we agree with a specific `31108` event. If this is the first `31108` published by a new member of the SEC it MUST include a pointer to the latest valid state of this SEC from which the new member will begin updating. | `["shadow", <ID of 31108 event> ]` |
| SHOULD | Current block, mostly for convenience. | `[ "bitcoin", "<current bitcoin height>:<hash>" ]` |

### Proofs
Some state changes MAY require a proof so that others can verify it if they wish. This can either contain the event ID of a proof, arbitrary data as a proof, or a full event as stringified JSON. A single update MAY contain multiple proofs.   
`[ "proof_id", <event ID of proof>, <relay hint> ]` 
`[ "proof_full", <stringified JSON of full event> ]`  
`[ "proof_raw", <proof type>:<proof data> ]`  


### Rulesets
Microsubjective Blockchain Rulesets are a way to compose consensus rules so that it's clear to users and client implementors exactly what needs to pass verification tests and how. The consensus rules that apply to an MSB need to be able to change over time so that the SEC can learn and adapt to its environment. Composable rules enable rapid experimentation and isolated failure.

Rulesets are identified with a hexadecimal code, for example 

### Verification of state
Verification is not strictly required, participants may choose to simply trust the current `31108` event published by someone they trust, or the SEC creator.

If participants wish to verify the full state, they may do so by fetching any proofs contained in the event, and fetching the `parent` event. Applying the proof events to the `parent` event in the context of the parent's `ruleset` should result in the same state as the current event. The process should be repeated until the `ignition` event is reached.

If the participant's pubkey has power over consensus (based on the current ruleset in the context of the current state), the participant SHOULD publish a `shadow` of the most recent `31108` event.

### Replay protection
To prevent the accidental or intentional replay of proofs, we include a bloom filter array and validate that the candidate proof has not yet been included in this MSB.

# MSBR 3340 (Nostrocket)
##### NIP1962 STATUS:RAW; Version: 00; Hex code `334000`
>todo: split this out into its own thing.  
>todo: NIP 1848 (votepower); NIP1409 (sale of merits); 1602/1603 (merit requests and votes); NIP1908 (products); NIP886 (Sybil Trees).

### Ruleset Updates
This MSBR requires `>80%` of the SEC's `votepower` to add/remove ruleset identifiers and `>60%` to increment a ruleset identifier to the next stable version.

### Problem Statement: 
A problem SHOULD be included by the project creator in their `ignition` event.
`[ "problem", 1971:<problem creator pubkey>:<kind 1971 problem tracker event d tag>, <relay hint> ]`

The problem statement MAY be altered by `>80%` of the SEC's `votepower`.
### Mission Statement: the stated reason for the SEC's existence
A mission statement SHOULD be included by the project creator in their `ignition` event.
`[ "mission", <string, less than 140 characters> ]`

The mission statement MAY be altered by `>80%` of the SEC's `votepower`.

---
>#### Case Study: Reddit
>**Problem:** how to get the news off an Internet with far too many interesting sources of information.   
>**Mission:** _the front page of the Internet._

---

### Repositories
At minimum ONE repository SHOULD be included by the project creator in their `ignition` event.
`[ "repo", 30617:<repo publisher pubkey>:<NIP34 repo announcement d tag>, <relay hint> ]`

Repositories MAY be altered by `>80%` of the SEC's `votepower`.

### Products
Product listings index    
`[ "product", 1908:<product publisher pubkey>:<kind 1908 product d tag>, <relay hint>, <sats price>, <JSON stringified purchases> ]`   

Payments tracking for products, embedded as stringified JSON array in the `"product"`   
`["<zap receipt ID>:<buyer pubkey>:<witnessed at block height>", ...]`    

Updates to product payments SHOULD be accompanied by a proof (stringified zap receipt).

Products MAY be altered by `>80%` of the SEC's `votepower`.

### Merits
Merits are the canonical representation of equity within a SEC. Upon approval of a new Merit Request, or a transfer or sale of an approved merit request (see NIP 1409), a tag entry is created or modified.   
`[ "merit", "<owner pubkey>:<event ID of approved merit request>:<current leadtime>:<last leadtime update>:<number of merits>" ]`

Updates to merits SHOULD be accompanied by a proof of either:   
1. a stringified merit request kind `1602` and stringified votes of kind `1603`  
2. a Bitcoin TXID in the case of the sale of an approved merit request (see NIP 1409)

### Satflow
Instead of tracking satflow based on each pubkey (an accounts paradigm), we do it using approved merit requests (something akin to the UTXO model). This allows merits to be transacted without losing their satflow history.

For each approved merit request:   
`[ "sats", "<merit request ID>:<amount outstanding>:<amount paid>" ] `

Decrements to the amount outstanding SHOULD be accompanied by a proof (stringified zap receipt and the recipients current kind 0 event with the zapper pubkey).

### Votepower
Some merit holders in a SEC may have `votepower`. Votepower is how we quantify a Participant's _skin in the game_.

`Votepower = Merits * Leadtime`

1. Every Approved Merit Request's `Leadtime` starts at `0`.
2. An Approved Merit Request cannot be spent/transferred/sold if its `Leadtime > 0`.
3. A Participant MAY increment or decrement the Leadtime on an Approved Merit Request owned by them ONCE every 2,016 blocks (but can't become negative) 

Participants who hold merits with a votepower `>0` SHOULD publish `kind 31108` state events which allow consumers of these events to verify that there is consensus over the current state. They may also simply `shadow` someone else who also has votepower.

To validate if consensus has been reached over a given state, Participants fetch all the latest state events from each pubkey that has votepower `>0` in their last known state (or just start with the `ignition` event). This section will be updated with further details once fully implemented.

If 100% of the current `votepower` is in agreement over the current state, we don't need to validate any proofs other than that required to validate the current set of pubkeys holding votepower.


## A Note About Handling of Incoming Payments
An SEC has three options for handling the distribution of incoming payments (for products/services created by the SEC).   
#### Round Robin
When someone wants to purchase a product/service from an SEC, they are provided with an invoice from the next pubkey in a round robin derived from ratio between how many merits each pubkey holds and how many sats they have recieved for the life of the SEC. The distribution of incoming payments is eventually-consistent with the distribution of merits.

This is a totally non-custodial way to operate an SEC.

#### Cashu 
The creator of an SEC can spin up a Cashu mint on top of any funding source, with a dedicated LUD16 address for each product/service. 

When receving an incoming payment, their mint DMs each merit holder with the correct proportion of tokens based on their proportion of merits.

Merit holders can request a withdrawal at any time.

This can also be a service provided by another SEC. 

#### Manual Stop-gap
The simplest way to handle incoming payments is for the creator of an SEC to create a new LUD16 for incoming payments and provide a pubkey for valid zap receipts. When a zap receipt is published, the `kind 31108` event is updated to reflect the new outstanding amount owed to each merit holder. Upon withdrawal request, the SEC creator SHOULD zap the merit holder and update his `31108` event to reflect the new state.



