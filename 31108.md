# NIP 31108 - Sovereign Economic Communities (SEC)
##### NIP1962 STATUS: RAW
>todo: NIP 1848 (votepower); NIP1409 (sale of merits); 1602/1603 merit requests and votes; NIP1908 (products)

A Sovereign Economic Community is a coordination layer that harmonises Sovereign Human Action for fun and profit.

## Protocol Flow
1. A person publishes a `kind 31108` event to  create a new SEC. This is called the `ignition` event.
2. If the creator of an SEC wants to update something, they may do so by publishing a replacement `31108` event with the relevant modifications and proof(s).
3. All replacement `31108` events (i.e. all except the `ignition` event) MUST have a pointer to the ignition event's ID (not just an `a` tag), AND a pointer to the ID of the most recent update published by the pubkey performing the update.
4. When new members join an SEC and have `votepower > 0` (see NIP 1848), they SHOULD validate and publish the state of the SEC in their own 31108 event.

## SEC State Event (kind: 31108)
The following tags are indicated for use in kind 31108 events.

### Metadata
| RFC 2119 | Description | Spec or Example |
|---|---|---|
|SHOULD| pointer to the `kind 31108` ignition event for this SEC. | `[ "ignition", <event ID> ]` |
|SHOULD| pointer to the ID of the last `kind 31108` that this replacement is updating (MUST be the same pubkey) | `[ "previous", <event ID> ]` |
| MUST | The name of this SEC | `[ "d", <name of this SEC> ]` |
| OPTIONAL | if this is the first `31108` published by a new member of the SEC it MUST include a pointer to the latest valid state of this SEC from which the new member will begin updating | `["shadow", <ID of 31108 event> ]` |
| SHOULD | Current block | `[ "bitcoin", "<current bitcoin height>:<hash>" ]` |

### Problem Statement: 
`[ "problem", 1971:<problem creator pubkey>:<kind 1971 problem tracker event d tag>, <relay hint> ]`
### Mission Statement: the stated reason for the SEC's existence
`[ "mission", <string, less than 140 characters> ]`
>#### Case Study: Reddit
>**Problem:** how to get the news off an Internet with far too many interesting sources of information.   
>**Mission:** _the front page of the Internet._

### Repositories
`[ "repo", 30617:<repo publisher pubkey>:<NIP34 repo announcement d tag>, <relay hint> ]`

### Products
Product listings index    
`[ "product", 1908:<product publisher pubkey>:<kind 1908 product d tag>, <relay hint>, <sats price>, <JSON stringified purchases> ]`   

Payments tracking for products, embedded as stringified JSON array in the `"product"`   
`["<zap receipt ID>:<buyer pubkey>:<witnessed at block height>", ...]`    

Updates to product payments SHOULD be accompanied by a proof (stringified zap receipt).

### Merits
Merits are the canonical representation of equity within a SEC. Upon approval of a new Merit Request, or a transfer or sale of an approved merit request (see NIP 1409), a tag entry is created or modified.   
`[ "merit", "<owner pubkey>:<event ID of approved merit request>:<current leadtime>:<last leadtime update>:<number of merits>" ]`

Updates to merits SHOULD be accompanied by a proof of either:   
1. a stringified merit request kind `1602` and stringified votes of kind `1603`  
2. a Bitcoin TXID in the case of the sale of an approved merit request (see NIP 1409)

### Satflow
Instead of tracking satflow based on each pubkey (an accounts paradigm), we do it using approved merit requests (something akin to the UTXO model). This allows merits to be transacted without losing their satflow history.

For each approved merit request:   
`[ "sats", "<merit request ID>:<amount outstanding>:<amount paid>" ] `

Decrements to the amount outstanding SHOULD be accompanied by a proof (stringified zap receipt and the recipients current kind 0 event with the zapper pubkey).

### Proofs
Some state changes require a proof so that others can verify it if they wish. This can either contain the event ID of a proof, arbitrary data as a proof, or a full event as stringified JSON. A single update MAY contain multiple proofs.   
`[ "proof_id", <event ID of proof>, <relay hint> ]`  
`[ "proof_data", <proof type>:<proof data> ]`  
`[ "proof_full", <stringified JSON of full event> ]`

## Handling of Incoming Payments
An SEC has three options for handling the distribution of incoming payments (for products/services created by the SEC).   
#### Round Robin
When someone wants to purchase a product/service from an SEC, they are provided with an invoice from the next pubkey in a round robin derived from ratio between how many merits each pubkey holds and how many sats they have recieved for the life of the SEC. The distribution of incoming payments is eventually-consistent with the distribution of merits.

This is a totally non-custodial way to operate an SEC.

#### Cashu 
The creator of an SEC can spin up a Cashu mint on top of any funding source, with a dedicated LUD16 address for each product/service. 

When receving an incoming payment, their mint DMs each merit holder with the correct proportion of tokens based on their proportion of merits.

Merit holders can request a withdrawal at any time.

This can also be a service provided by another SEC. 

#### Manual Stop-gap
The simplest way to handle incoming payments is for the creator of an SEC to create a new LUD16 for incoming payments and provide a pubkey for valid zap receipts. When a zap receipt is published, the `kind 31108` event is updated to reflect the new outstanding amount owed to each merit holder. Upon withdrawal request, the SEC creator SHOULD zap the merit holder and update his `31108` event to reflect the new state.

## Verification of state
Verification is not strictly required, participants may choose to simply trust the current published state of the SEC creator.

If participants wish to validate the full state as published by the SEC creator, they may do so by taking the latest (replaceable) event and fetching any proofs, and fetching the `previous` event. Applying the proofs to the `previous` event should result in the same state as the current event. The process should be repeated until the `ignition` event is reached.

## Consensus over the current state
Validating consensus over the current state is possible but probably won't be neccessary until SECs begin generating real value.

Some participants in a SEC may have votepower. Votepower is how we quantify a Participant's _skin in the game_ and is described in NIP1848. 

Participants who hold merits with a votepower `>0` SHOULD publish `kind 31108` state events which allow consumers of these events to verify that there is consensus over the current state. They may also simply `shadow` someone else who also has votepower.

To validate if consensus has been reached over a given state, Participants fetch all the latest state events from each pubkey that has votepower `>0` in their last known state (or just start with the `ignition` event). This section will be updated with further details once fully implemented.